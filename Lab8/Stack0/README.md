## [Stack Zero](https://exploit.education/protostar/stack-zero/)

Даний рівень вводить у концепцію, що доступ до пам'яті може здійснюватися поза межами виділеної області, як розміщуються змінні стека, 
і що зміни поза межами виділеної пам'яті можуть змінити виконання програми.

Переходимо у директорію із завданням:  
```cd /opt/protostar/bin/```

Вихідний код:  
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

```volatile``` інформує компілятор, що значення змінної може змінюватися ззовні. 
Це може статися під керуванням операційної системи, апаратних засобів чи іншого потоку. 
Оскільки значення може змінитися, компілятор щоразу завантажує його із пам'яті. 

	Буфер програми має розмір у 64 байти. У даний буфер буде записаний рядок за допомогою функції ```gets()```. 
Якщо прочитати опис даної функції, то можна побачити, що вона зчитує рядок із ```stdin``` і поміщає його у масив, який указується аргументом. 
Зчитування відбувається поки не буде досягнуто символу переходу на новий рядок або досягнуто кінця файлу. 
Зчитування рядка не обмежується розміром масиву, тому може виникнути переповнення масиву і несанкціонований запис у пам'ять.  
	Змінна ```modified``` завжди рівна 0, тому повинен виводитися надпис "Try again?". 
Якщо запустити програму і передати їй рядок, який поміститься у буфер, то все працюватиме правильно і ми отримаємо надпис "Try again?". 
Однак, якщо використати вразливість функції ```gets()``` і передати рядок розміром більше 64 байти, то змінна ```modified``` буде перезаписана. Що нам і потрібно!

```python -c "print 'A' * 65" | ./stack0```